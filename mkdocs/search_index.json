{
    "docs": [
        {
            "location": "/",
            "text": "zend-xmlrpc\n\n\n\n\n\n\nFrom its home page, XML-RPC is described as a \u201d...remote procedure calling using\nHTTP as the transport and XML as the encoding. XML-RPC is designed to be as\nsimple as possible, while allowing complex data structures to be transmitted,\nprocessed and returned.\u201d\n\n\nZend\\XmlRpc\n provides support for both consuming remote XML-RPC services and\nbuilding new XML-RPC servers.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-xmlrpc/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-xmlrpc/",
            "title": "Home"
        },
        {
            "location": "/#zend-xmlrpc",
            "text": "From its home page, XML-RPC is described as a \u201d...remote procedure calling using\nHTTP as the transport and XML as the encoding. XML-RPC is designed to be as\nsimple as possible, while allowing complex data structures to be transmitted,\nprocessed and returned.\u201d  Zend\\XmlRpc  provides support for both consuming remote XML-RPC services and\nbuilding new XML-RPC servers.   File issues at https://github.com/zendframework/zend-xmlrpc/issues  Documentation is at https://zendframework.github.io/zend-xmlrpc/",
            "title": "zend-xmlrpc"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nFrom its \nhome page\n, XML-RPC is described as:\n\n\n\n\n\"...remote procedure calling using HTTP as the transport and XML as the\nencoding. XML-RPC is designed to be as simple as possible, while allowing\ncomplex data structures to be transmitted, processed and returned.\"\n\n\n\n\nzend-xmlrpc provides support for both consuming remote XML-RPC services and\nproviding XML-RPC servers.\n\n\nQuick Start\n\n\nThe following demonstrates the most basic use case for \nZend\\XmlRpc\\Server\n:\n\n\nclass Greeter\n{\n    /**\n    * Say hello to someone.\n    *\n    * @param string $name Who to greet\n    * @return string\n    */\n    public function sayHello($name = 'Stranger')\n    {\n        return sprintf(\nHello %s!\n, $name);\n    }\n}\n\n$server = new Zend\\XmlRpc\\Server;\n\n// Our Greeter class will be called \ngreeter\n from the client:\n$server-\nsetClass('Greeter', 'greeter');\n$server-\nhandle();\n\n\n\n\n\n\nDocblock annotations are required\n\n\nFunction and method docblocks containing parameter and return value\nannotations \nare required\n when exposing them via \nZend\\XmlRpc\\Server\n. The\nvalues will be used to validate method parameters and provide method\nsignatures to clients.\n\n\nDocblock descriptions will also be used to provide method help text.\n\n\n\n\nThe following demonstrates an XML-RPC client that can consume the above service:\n\n\n$client = new Zend\\XmlRpc\\Client('http://example.com/xmlrpcserver.php');\n\necho $client-\ncall('greeter.sayHello');\n// will output \nHello Stranger!\n\n\necho $client-\ncall('greeter.sayHello', ['Dude']);\n// will output \nHello Dude!",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "From its  home page , XML-RPC is described as:   \"...remote procedure calling using HTTP as the transport and XML as the\nencoding. XML-RPC is designed to be as simple as possible, while allowing\ncomplex data structures to be transmitted, processed and returned.\"   zend-xmlrpc provides support for both consuming remote XML-RPC services and\nproviding XML-RPC servers.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#quick-start",
            "text": "The following demonstrates the most basic use case for  Zend\\XmlRpc\\Server :  class Greeter\n{\n    /**\n    * Say hello to someone.\n    *\n    * @param string $name Who to greet\n    * @return string\n    */\n    public function sayHello($name = 'Stranger')\n    {\n        return sprintf( Hello %s! , $name);\n    }\n}\n\n$server = new Zend\\XmlRpc\\Server;\n\n// Our Greeter class will be called  greeter  from the client:\n$server- setClass('Greeter', 'greeter');\n$server- handle();",
            "title": "Quick Start"
        },
        {
            "location": "/intro/#docblock-annotations-are-required",
            "text": "Function and method docblocks containing parameter and return value\nannotations  are required  when exposing them via  Zend\\XmlRpc\\Server . The\nvalues will be used to validate method parameters and provide method\nsignatures to clients.  Docblock descriptions will also be used to provide method help text.   The following demonstrates an XML-RPC client that can consume the above service:  $client = new Zend\\XmlRpc\\Client('http://example.com/xmlrpcserver.php');\n\necho $client- call('greeter.sayHello');\n// will output  Hello Stranger! \n\necho $client- call('greeter.sayHello', ['Dude']);\n// will output  Hello Dude!",
            "title": "Docblock annotations are required"
        },
        {
            "location": "/client/",
            "text": "XML-RPC Clients\n\n\nzend-xmlrpc provides support for consuming remote XML-RPC services as a client\nvia the \nZend\\XmlRpc\\Client\n class. Its major features include:\n\n\n\n\nautomatic type conversion between PHP and XML-RPC\n\n\na server proxy object (to simplify method resolution)\n\n\naccess to server introspection capabilities\n\n\n\n\nMethod Calls\n\n\nThe constructor of \nZend\\XmlRpc\\Client\n receives the URL of the remote XML-RPC\nserver endpoint as its first parameter. The new instance returned may be used to\ncall any number of remote methods at that endpoint.\n\n\nTo call a remote method with the XML-RPC client, instantiate it and use the\n\ncall()\n instance method. The code sample below uses a demonstration XML-RPC\nserver from \nAdvogato\n. You can use it for testing or\nexploring the \nZend\\XmlRpc\n components.\n\n\nXML-RPC Method Call\n\n\n$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\nvar_dump($client-\ncall('test.guess'));\n\n// ['You guessed', 42]\n\n\n\n\nThe XML-RPC value returned from the remote method call will be automatically\nunmarshaled and cast to the equivalent PHP native type. In the example above, a\nPHP array is returned containing a string and an integer value; you can\nimmediately use the returned value.\n\n\nThe first parameter of the \ncall()\n method receives the name of the remote\nmethod to call. If the remote method requires any parameters, these can be sent\nby supplying a second, optional parameter to \ncall()\n with an \narray\n of values\nto pass to the remote method:\n\n\nXML-RPC Method Call with Parameters\n\n\n$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\n$arg1 = 5;\n$arg2 = 7;\n\n$result = $client-\ncall('test.sumProd', [$arg1, $arg2]);\n\n// $result is a native PHP type\n\n\n\n\nIf the remote method doesn't require parameters, this optional parameter may\neither be left out or an empty \n[]\n passed to it. The array of parameters for\nthe remote method can contain native PHP types, \nZend\\XmlRpc\\Value\n objects, or\na mix of each.\n\n\nThe \ncall()\n method will automatically convert the XML-RPC response and return\nits equivalent PHP native type. A \nZend\\XmlRpc\\Response\n object for the return\nvalue will also be available by calling the \ngetLastResponse()\n method after the\ncall.\n\n\nTypes and Conversions\n\n\nSome remote method calls require parameters. These are given to the \ncall()\n\nmethod of \nZend\\XmlRpc\\Client\n as an array in the second parameter. Each\nparameter may be given as either a native PHP type which will be automatically\nconverted, or as an object representing a specific XML-RPC type (one of the\n\nZend\\XmlRpc\\Value\n objects).\n\n\nPHP Native Types as Parameters\n\n\nParameters may be passed to \ncall()\n as native PHP variables, meaning as a \nstring\n, \ninteger\n,\n\nfloat\n, \nboolean\n, \narray\n, or an \nobject\n. In this case, each PHP native type will be\nauto-detected and converted into one of the XML-RPC types according to this table:\n\n\n\n\n\n\n\n\nPHP Native Type\n\n\nXML-RPC Type\n\n\n\n\n\n\n\n\n\n\ninteger\n\n\nint\n\n\n\n\n\n\nZend\\Math\\BigInteger\\BigInteger\n\n\ni8\n\n\n\n\n\n\ndouble\n\n\ndouble\n\n\n\n\n\n\nboolean\n\n\nboolean\n\n\n\n\n\n\nstring\n\n\nstring\n\n\n\n\n\n\nnull\n\n\nnil\n\n\n\n\n\n\narray\n\n\narray\n\n\n\n\n\n\nassociative array\n\n\nstruct\n\n\n\n\n\n\nobject\n\n\narray\n\n\n\n\n\n\nDateTime\n\n\ndateTime.iso8601\n\n\n\n\n\n\nDateTime\n\n\ndateTime.iso8601\n\n\n\n\n\n\n\n\n\n\nWhat type do empty arrays get cast to?\n\n\nPassing an empty array to an XML-RPC method is problematic, as it could\nrepresent either an array or a struct. \nZend\\XmlRpc\\Client\n detects such\nconditions and makes a request to the server's \nsystem.methodSignature\n method\nto determine the appropriate XML-RPC type to cast to.\n\n\nHowever, this in itself can lead to issues. First off, servers that do not\nsupport \nsystem.methodSignature\n will log failed requests, and\n\nZend\\XmlRpc\\Client\n will resort to casting the value to an XML-RPC array\ntype. Additionally, this means that any call with array arguments will result\nin an additional call to the remote server.\n\n\nTo disable the lookup entirely, you can call the \nsetSkipSystemLookup()\n\nmethod prior to making your XML-RPC call:\n\n\n$client-setSkipSystemLookup(true);\n$result = $client-call('foo.bar', array(array()));\n\n\n\n\n\n\nZend\\XmlRpc\\Value Objects as Parameters\n\n\nParameters may also be created as \nZend\\XmlRpc\\Value\n instances to specify an\nexact XML-RPC type.  The primary reasons for doing this are:\n\n\n\n\nWhen you want to make sure the correct parameter type is passed to the\n  procedure (i.e. the procedure requires an integer and you may get it from a\n  database as a string)\n\n\nWhen the procedure requires \nbase64\n or \ndateTime.iso8601\n type (which doesn't\n  exists as a PHP native type)\n\n\nWhen auto-conversion may fail (i.e. you want to pass an empty XML-RPC struct\n  as a parameter.  Empty structs are represented as empty arrays in PHP but, if\n  you give an empty array as a parameter it will be auto-converted to an XML-RPC\n  array since it's not an associative array)\n\n\n\n\nThere are two ways to create a \nZend\\XmlRpc\\Value\n object: instantiate one of the\n\nZend\\XmlRpc\\Value\n subclasses directly, or use the static factory method\n\nZend\\XmlRpc\\AbstractValue::getXmlRpcValue()\n.\n\n\n\n\n\n\n\n\nXML-RPC Type\n\n\nZend\\XmlRpc\\AbstractValue\n Constant\n\n\nZend\\XmlRpc\\Value\n Object\n\n\n\n\n\n\n\n\n\n\nint\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_INTEGER\n\n\nZend\\XmlRpc\\Value\\Integer\n\n\n\n\n\n\ni4\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_I4\n\n\nZend\\XmlRpc\\Value\\Integer\n\n\n\n\n\n\ni8\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_I8\n\n\nZend\\XmlRpc\\Value\\BigInteger\n\n\n\n\n\n\nex:i8\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_APACHEI8\n\n\nZend\\XmlRpc\\Value\\BigInteger\n\n\n\n\n\n\ndouble\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_DOUBLE\n\n\nZend\\XmlRpc\\ValueDouble\n\n\n\n\n\n\nboolean\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_BOOLEAN\n\n\nZend\\XmlRpc\\Value\\Boolean\n\n\n\n\n\n\nstring\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_STRING\n\n\nZend\\XmlRpc\\Value\\Text\n\n\n\n\n\n\nnil\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_NIL\n\n\nZend\\XmlRpc\\Value\\Nil\n\n\n\n\n\n\nex:nil\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_APACHENIL\n\n\nZend\\XmlRpc\\Value\\Nil\n\n\n\n\n\n\nbase64\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_BASE64\n\n\nZend\\XmlRpc\\Value\\Base64\n\n\n\n\n\n\ndateTime.iso8601\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_DATETIME\n\n\nZend\\XmlRpc\\Value\\DateTime\n\n\n\n\n\n\narray\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_ARRAY\n\n\nZend\\XmlRpc\\Value\\Array\n\n\n\n\n\n\nstruct\n\n\nZend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_STRUCT\n\n\nZend\\XmlRpc\\Value\\Struct\n\n\n\n\n\n\n\n\n\n\nAutomatic Conversion\n\n\nWhen building a new \nZend\\XmlRpc\\Value\n object, its value is set by a PHP\ntype. The PHP type will be converted to the specified type using PHP casting.\nFor example, if a string is given as a value to the\n\nZend\\XmlRpc\\Value\\Integer\n object, it will be converted using \n(int) $value\n.\n\n\n\n\nServer Proxy Object\n\n\nAnother way to call remote methods with the XML-RPC client is to use the server\nproxy. This is a PHP object that proxies a remote XML-RPC namespace, making it\nwork as close to a native PHP object as possible.\n\n\nTo instantiate a server proxy, call the \ngetProxy()\n instance method of\n\nZend\\XmlRpc\\Client\n. This will return an instance of \nZend\\XmlRpc\\Client\\ServerProxy\n.\nAny method call on the server proxy object will be forwarded to the remote, and\nparameters may be passed like any other PHP method.\n\n\nProxy the Default Namespace\n\n\n$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\n$service  = $client-\ngetProxy();           // Proxy the default namespace\n$products = $service-\ntest-\nsumProd(5, 7); // test.sumProd(5, 7) returns [12, 35]\n\n\n\n\nThe \ngetProxy()\n method receives an optional argument specifying which namespace of the remote\nserver to proxy. If it does not receive a namespace, the default namespace will be proxied. In the\nnext example, the 'test' namespace will be proxied:\n\n\nProxy Any Namespace\n\n\n$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\n$test  = $client-\ngetProxy('test'); // Proxy the \ntest\n namespace\n$hello = $test-\nsumProd(5, 7);      // test.sumProd(5, 7) returns [12, 35]\n\n\n\n\nIf the remote server supports nested namespaces of any depth, these can also be\nused through the server proxy. For example, if the server in the example above\nhad a method \ntest.foo.bar()\n, it could be called as \n$test-\nfoo-\nbar()\n.\n\n\nError Handling\n\n\nTwo kinds of errors can occur during an XML-RPC method call: HTTP errors and\nXML-RPC faults.  \nZend\\XmlRpc\\Client\n recognizes each and provides the ability\nto detect and trap them independently.\n\n\nHTTP Errors\n\n\nIf any HTTP error occurs, such as the remote HTTP server returns a \n404 Not\nFound\n, a \nZend\\XmlRpc\\Client\\Exception\\HttpException\n will be thrown.\n\n\nHandling HTTP Errors\n\n\n$client = new Zend\\XmlRpc\\Client('http://foo/404');\n\ntry {\n    $client-\ncall('bar', array($arg1, $arg2));\n} catch (Zend\\XmlRpc\\Client\\Exception\\HttpException $e) {\n    // $e-\ngetCode() returns 404\n    // $e-\ngetMessage() returns \nNot Found\n\n}\n\n\n\n\nRegardless of how the XML-RPC client is used, the \nZend\\XmlRpc\\Client\\Exception\\HttpException\n\nwill be thrown whenever an HTTP error occurs.\n\n\nXML-RPC Faults\n\n\nAn XML-RPC fault is analogous to a PHP exception. It is a special type returned\nfrom an XML-RPC method call that has both an error code and an error message.\nXML-RPC faults are handled differently depending on the context of how the\n\nZend\\XmlRpc\\Client\n is used.\n\n\nWhen the \ncall()\n method or the server proxy object is used, an XML-RPC fault\nwill result in a \nZend\\XmlRpc\\Client\\Exception\\FaultException\n being thrown. The\ncode and message of the exception will map directly to their respective values\nin the original XML-RPC fault response.\n\n\nHandling XML-RPC Faults\n\n\n$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\ntry {\n    $client-\ncall('badMethod');\n} catch (Zend\\XmlRpc\\Client\\Exception\\FaultException $e) {\n    // $e-\ngetCode() returns 1\n    // $e-\ngetMessage() returns \nUnknown method\n\n}\n\n\n\n\nWhen the \ncall()\n method is used to make the request, the\n\nZend\\XmlRpc\\Client\\Exception\\FaultException\n will be thrown on fault. A\n\nZend\\XmlRpc\\Response\n object containing the fault will also be available by\ncalling \ngetLastResponse()\n.\n\n\nWhen the \ndoRequest()\n method is used to make the request, it will not throw the\nexception. Instead, it will return a \nZend\\XmlRpc\\Response\n object that, on\nerror, contains the fault. This can be checked with \nisFault()\n instance method\nof \nZend\\XmlRpc\\Response\n.\n\n\nServer Introspection\n\n\nSome XML-RPC servers support the de facto introspection methods under the\nXML-RPC \nsystem.\n namespace. \nZend\\XmlRpc\\Client\n provides special support for\nservers with these capabilities.\n\n\nA \nZend\\XmlRpc\\Client\\ServerIntrospection\n instance may be retrieved by calling\nthe \ngetIntrospector()\n method of \nZend\\XmlRpc\\Client\n. It can then be used to\nperform introspection operations on the server.\n\n\n$client = new Zend\\XmlRpc\\Client('http://example.com/xmlrpcserver.php');\n$introspector = $client-\ngetIntrospector();\nforeach ($introspector-\nlistMethods() as $method) {\n    echo \nMethod: \n . $method . \n\\n\n;\n}\n\n\n\n\nThe following methods are available for introspection:\n\n\n\n\ngetSignatureForEachMethod\n: Returns the signature for each method on the\n  server.\n\n\ngetSignatureForEachMethodByMulticall($methods=null)\n: Attempt to get the\n  method signatures in one request via \nsystem.multicall\n. Optionally pass an\n  array of method names.\n\n\ngetSignatureForEachMethodByLooping($methods=null)\n: Get the method signatures\n  for every method by successively calling \nsystem.methodSignature\n. Optionally\n  pass an array of method names\n\n\ngetMethodSignature($method)\n: Get the method's signature for \n$method\n.\n\n\nlistMethods\n: List all methods on the server.\n\n\n\n\nFrom Request to Response\n\n\nUnder the hood, the \ncall()\n instance method of \nZend\\XmlRpc\\Client\n builds a\nrequest object (\nZend\\XmlRpc\\Request\n) and sends it to another method,\n\ndoRequest()\n, that returns a response object (\nZend\\XmlRpc\\Response\n).\n\n\nThe \ndoRequest()\n method is also available for use directly.\n\n\nProcessing Request to Response\n\n\n$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\n$request = new Zend\\XmlRpc\\Request();\n$request-\nsetMethod('test.guess');\n\n$client-\ndoRequest($request);\n\n// $client-\ngetLastRequest() returns instanceof Zend\\XmlRpc\\Request\n// $client-\ngetLastResponse() returns instanceof Zend\\XmlRpc\\Response\n\n\n\n\nWhenever an XML-RPC method call is made by the client through any means \n\neither the \ncall()\n method, \ndoRequest()\n method, or server proxy \n the\nlast request object and its resultant response object will always be available\nthrough the methods \ngetLastRequest()\n and \ngetLastResponse()\n respectively.\n\n\nHTTP Client and Testing\n\n\nIn all of the prior examples, an HTTP client was never specified. When this is\nthe case, a new instance of \nZend\\Http\\Client\n will be created with its default\noptions and used by \nZend\\XmlRpc\\Client\n automatically.\n\n\nThe HTTP client can be retrieved at any time with the \ngetHttpClient()\n method.\nFor most cases, the default HTTP client will be sufficient. However, the\n\nsetHttpClient()\n method allows for a different HTTP client instance to be\ninjected.\n\n\nThe \nsetHttpClient()\n is particularly useful for unit testing. When combined\nwith \nZend\\Http\\Client\\Adapter\\Test\n, remote services can be mocked out for\ntesting. See the unit tests for \nZend\\XmlRpc\\Client\n for examples of how to do\nthis.",
            "title": "XML-RPC Clients"
        },
        {
            "location": "/client/#xml-rpc-clients",
            "text": "zend-xmlrpc provides support for consuming remote XML-RPC services as a client\nvia the  Zend\\XmlRpc\\Client  class. Its major features include:   automatic type conversion between PHP and XML-RPC  a server proxy object (to simplify method resolution)  access to server introspection capabilities",
            "title": "XML-RPC Clients"
        },
        {
            "location": "/client/#method-calls",
            "text": "The constructor of  Zend\\XmlRpc\\Client  receives the URL of the remote XML-RPC\nserver endpoint as its first parameter. The new instance returned may be used to\ncall any number of remote methods at that endpoint.  To call a remote method with the XML-RPC client, instantiate it and use the call()  instance method. The code sample below uses a demonstration XML-RPC\nserver from  Advogato . You can use it for testing or\nexploring the  Zend\\XmlRpc  components.",
            "title": "Method Calls"
        },
        {
            "location": "/client/#xml-rpc-method-call",
            "text": "$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\nvar_dump($client- call('test.guess'));\n\n// ['You guessed', 42]  The XML-RPC value returned from the remote method call will be automatically\nunmarshaled and cast to the equivalent PHP native type. In the example above, a\nPHP array is returned containing a string and an integer value; you can\nimmediately use the returned value.  The first parameter of the  call()  method receives the name of the remote\nmethod to call. If the remote method requires any parameters, these can be sent\nby supplying a second, optional parameter to  call()  with an  array  of values\nto pass to the remote method:",
            "title": "XML-RPC Method Call"
        },
        {
            "location": "/client/#xml-rpc-method-call-with-parameters",
            "text": "$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\n$arg1 = 5;\n$arg2 = 7;\n\n$result = $client- call('test.sumProd', [$arg1, $arg2]);\n\n// $result is a native PHP type  If the remote method doesn't require parameters, this optional parameter may\neither be left out or an empty  []  passed to it. The array of parameters for\nthe remote method can contain native PHP types,  Zend\\XmlRpc\\Value  objects, or\na mix of each.  The  call()  method will automatically convert the XML-RPC response and return\nits equivalent PHP native type. A  Zend\\XmlRpc\\Response  object for the return\nvalue will also be available by calling the  getLastResponse()  method after the\ncall.",
            "title": "XML-RPC Method Call with Parameters"
        },
        {
            "location": "/client/#types-and-conversions",
            "text": "Some remote method calls require parameters. These are given to the  call() \nmethod of  Zend\\XmlRpc\\Client  as an array in the second parameter. Each\nparameter may be given as either a native PHP type which will be automatically\nconverted, or as an object representing a specific XML-RPC type (one of the Zend\\XmlRpc\\Value  objects).",
            "title": "Types and Conversions"
        },
        {
            "location": "/client/#php-native-types-as-parameters",
            "text": "Parameters may be passed to  call()  as native PHP variables, meaning as a  string ,  integer , float ,  boolean ,  array , or an  object . In this case, each PHP native type will be\nauto-detected and converted into one of the XML-RPC types according to this table:     PHP Native Type  XML-RPC Type      integer  int    Zend\\Math\\BigInteger\\BigInteger  i8    double  double    boolean  boolean    string  string    null  nil    array  array    associative array  struct    object  array    DateTime  dateTime.iso8601    DateTime  dateTime.iso8601",
            "title": "PHP Native Types as Parameters"
        },
        {
            "location": "/client/#what-type-do-empty-arrays-get-cast-to",
            "text": "Passing an empty array to an XML-RPC method is problematic, as it could\nrepresent either an array or a struct.  Zend\\XmlRpc\\Client  detects such\nconditions and makes a request to the server's  system.methodSignature  method\nto determine the appropriate XML-RPC type to cast to.  However, this in itself can lead to issues. First off, servers that do not\nsupport  system.methodSignature  will log failed requests, and Zend\\XmlRpc\\Client  will resort to casting the value to an XML-RPC array\ntype. Additionally, this means that any call with array arguments will result\nin an additional call to the remote server.  To disable the lookup entirely, you can call the  setSkipSystemLookup() \nmethod prior to making your XML-RPC call:  $client-setSkipSystemLookup(true);\n$result = $client-call('foo.bar', array(array()));",
            "title": "What type do empty arrays get cast to?"
        },
        {
            "location": "/client/#zend92xmlrpc92value-objects-as-parameters",
            "text": "Parameters may also be created as  Zend\\XmlRpc\\Value  instances to specify an\nexact XML-RPC type.  The primary reasons for doing this are:   When you want to make sure the correct parameter type is passed to the\n  procedure (i.e. the procedure requires an integer and you may get it from a\n  database as a string)  When the procedure requires  base64  or  dateTime.iso8601  type (which doesn't\n  exists as a PHP native type)  When auto-conversion may fail (i.e. you want to pass an empty XML-RPC struct\n  as a parameter.  Empty structs are represented as empty arrays in PHP but, if\n  you give an empty array as a parameter it will be auto-converted to an XML-RPC\n  array since it's not an associative array)   There are two ways to create a  Zend\\XmlRpc\\Value  object: instantiate one of the Zend\\XmlRpc\\Value  subclasses directly, or use the static factory method Zend\\XmlRpc\\AbstractValue::getXmlRpcValue() .     XML-RPC Type  Zend\\XmlRpc\\AbstractValue  Constant  Zend\\XmlRpc\\Value  Object      int  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_INTEGER  Zend\\XmlRpc\\Value\\Integer    i4  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_I4  Zend\\XmlRpc\\Value\\Integer    i8  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_I8  Zend\\XmlRpc\\Value\\BigInteger    ex:i8  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_APACHEI8  Zend\\XmlRpc\\Value\\BigInteger    double  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_DOUBLE  Zend\\XmlRpc\\ValueDouble    boolean  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_BOOLEAN  Zend\\XmlRpc\\Value\\Boolean    string  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_STRING  Zend\\XmlRpc\\Value\\Text    nil  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_NIL  Zend\\XmlRpc\\Value\\Nil    ex:nil  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_APACHENIL  Zend\\XmlRpc\\Value\\Nil    base64  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_BASE64  Zend\\XmlRpc\\Value\\Base64    dateTime.iso8601  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_DATETIME  Zend\\XmlRpc\\Value\\DateTime    array  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_ARRAY  Zend\\XmlRpc\\Value\\Array    struct  Zend\\XmlRpc\\AbstractValue::XMLRPC_TYPE_STRUCT  Zend\\XmlRpc\\Value\\Struct",
            "title": "Zend\\XmlRpc\\Value Objects as Parameters"
        },
        {
            "location": "/client/#automatic-conversion",
            "text": "When building a new  Zend\\XmlRpc\\Value  object, its value is set by a PHP\ntype. The PHP type will be converted to the specified type using PHP casting.\nFor example, if a string is given as a value to the Zend\\XmlRpc\\Value\\Integer  object, it will be converted using  (int) $value .",
            "title": "Automatic Conversion"
        },
        {
            "location": "/client/#server-proxy-object",
            "text": "Another way to call remote methods with the XML-RPC client is to use the server\nproxy. This is a PHP object that proxies a remote XML-RPC namespace, making it\nwork as close to a native PHP object as possible.  To instantiate a server proxy, call the  getProxy()  instance method of Zend\\XmlRpc\\Client . This will return an instance of  Zend\\XmlRpc\\Client\\ServerProxy .\nAny method call on the server proxy object will be forwarded to the remote, and\nparameters may be passed like any other PHP method.",
            "title": "Server Proxy Object"
        },
        {
            "location": "/client/#proxy-the-default-namespace",
            "text": "$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\n$service  = $client- getProxy();           // Proxy the default namespace\n$products = $service- test- sumProd(5, 7); // test.sumProd(5, 7) returns [12, 35]  The  getProxy()  method receives an optional argument specifying which namespace of the remote\nserver to proxy. If it does not receive a namespace, the default namespace will be proxied. In the\nnext example, the 'test' namespace will be proxied:",
            "title": "Proxy the Default Namespace"
        },
        {
            "location": "/client/#proxy-any-namespace",
            "text": "$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\n$test  = $client- getProxy('test'); // Proxy the  test  namespace\n$hello = $test- sumProd(5, 7);      // test.sumProd(5, 7) returns [12, 35]  If the remote server supports nested namespaces of any depth, these can also be\nused through the server proxy. For example, if the server in the example above\nhad a method  test.foo.bar() , it could be called as  $test- foo- bar() .",
            "title": "Proxy Any Namespace"
        },
        {
            "location": "/client/#error-handling",
            "text": "Two kinds of errors can occur during an XML-RPC method call: HTTP errors and\nXML-RPC faults.   Zend\\XmlRpc\\Client  recognizes each and provides the ability\nto detect and trap them independently.",
            "title": "Error Handling"
        },
        {
            "location": "/client/#http-errors",
            "text": "If any HTTP error occurs, such as the remote HTTP server returns a  404 Not\nFound , a  Zend\\XmlRpc\\Client\\Exception\\HttpException  will be thrown.",
            "title": "HTTP Errors"
        },
        {
            "location": "/client/#handling-http-errors",
            "text": "$client = new Zend\\XmlRpc\\Client('http://foo/404');\n\ntry {\n    $client- call('bar', array($arg1, $arg2));\n} catch (Zend\\XmlRpc\\Client\\Exception\\HttpException $e) {\n    // $e- getCode() returns 404\n    // $e- getMessage() returns  Not Found \n}  Regardless of how the XML-RPC client is used, the  Zend\\XmlRpc\\Client\\Exception\\HttpException \nwill be thrown whenever an HTTP error occurs.",
            "title": "Handling HTTP Errors"
        },
        {
            "location": "/client/#xml-rpc-faults",
            "text": "An XML-RPC fault is analogous to a PHP exception. It is a special type returned\nfrom an XML-RPC method call that has both an error code and an error message.\nXML-RPC faults are handled differently depending on the context of how the Zend\\XmlRpc\\Client  is used.  When the  call()  method or the server proxy object is used, an XML-RPC fault\nwill result in a  Zend\\XmlRpc\\Client\\Exception\\FaultException  being thrown. The\ncode and message of the exception will map directly to their respective values\nin the original XML-RPC fault response.",
            "title": "XML-RPC Faults"
        },
        {
            "location": "/client/#handling-xml-rpc-faults",
            "text": "$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\ntry {\n    $client- call('badMethod');\n} catch (Zend\\XmlRpc\\Client\\Exception\\FaultException $e) {\n    // $e- getCode() returns 1\n    // $e- getMessage() returns  Unknown method \n}  When the  call()  method is used to make the request, the Zend\\XmlRpc\\Client\\Exception\\FaultException  will be thrown on fault. A Zend\\XmlRpc\\Response  object containing the fault will also be available by\ncalling  getLastResponse() .  When the  doRequest()  method is used to make the request, it will not throw the\nexception. Instead, it will return a  Zend\\XmlRpc\\Response  object that, on\nerror, contains the fault. This can be checked with  isFault()  instance method\nof  Zend\\XmlRpc\\Response .",
            "title": "Handling XML-RPC Faults"
        },
        {
            "location": "/client/#server-introspection",
            "text": "Some XML-RPC servers support the de facto introspection methods under the\nXML-RPC  system.  namespace.  Zend\\XmlRpc\\Client  provides special support for\nservers with these capabilities.  A  Zend\\XmlRpc\\Client\\ServerIntrospection  instance may be retrieved by calling\nthe  getIntrospector()  method of  Zend\\XmlRpc\\Client . It can then be used to\nperform introspection operations on the server.  $client = new Zend\\XmlRpc\\Client('http://example.com/xmlrpcserver.php');\n$introspector = $client- getIntrospector();\nforeach ($introspector- listMethods() as $method) {\n    echo  Method:   . $method .  \\n ;\n}  The following methods are available for introspection:   getSignatureForEachMethod : Returns the signature for each method on the\n  server.  getSignatureForEachMethodByMulticall($methods=null) : Attempt to get the\n  method signatures in one request via  system.multicall . Optionally pass an\n  array of method names.  getSignatureForEachMethodByLooping($methods=null) : Get the method signatures\n  for every method by successively calling  system.methodSignature . Optionally\n  pass an array of method names  getMethodSignature($method) : Get the method's signature for  $method .  listMethods : List all methods on the server.",
            "title": "Server Introspection"
        },
        {
            "location": "/client/#from-request-to-response",
            "text": "Under the hood, the  call()  instance method of  Zend\\XmlRpc\\Client  builds a\nrequest object ( Zend\\XmlRpc\\Request ) and sends it to another method, doRequest() , that returns a response object ( Zend\\XmlRpc\\Response ).  The  doRequest()  method is also available for use directly.",
            "title": "From Request to Response"
        },
        {
            "location": "/client/#processing-request-to-response",
            "text": "$client = new Zend\\XmlRpc\\Client('http://www.advogato.org/XMLRPC');\n\n$request = new Zend\\XmlRpc\\Request();\n$request- setMethod('test.guess');\n\n$client- doRequest($request);\n\n// $client- getLastRequest() returns instanceof Zend\\XmlRpc\\Request\n// $client- getLastResponse() returns instanceof Zend\\XmlRpc\\Response  Whenever an XML-RPC method call is made by the client through any means  \neither the  call()  method,  doRequest()  method, or server proxy   the\nlast request object and its resultant response object will always be available\nthrough the methods  getLastRequest()  and  getLastResponse()  respectively.",
            "title": "Processing Request to Response"
        },
        {
            "location": "/client/#http-client-and-testing",
            "text": "In all of the prior examples, an HTTP client was never specified. When this is\nthe case, a new instance of  Zend\\Http\\Client  will be created with its default\noptions and used by  Zend\\XmlRpc\\Client  automatically.  The HTTP client can be retrieved at any time with the  getHttpClient()  method.\nFor most cases, the default HTTP client will be sufficient. However, the setHttpClient()  method allows for a different HTTP client instance to be\ninjected.  The  setHttpClient()  is particularly useful for unit testing. When combined\nwith  Zend\\Http\\Client\\Adapter\\Test , remote services can be mocked out for\ntesting. See the unit tests for  Zend\\XmlRpc\\Client  for examples of how to do\nthis.",
            "title": "HTTP Client and Testing"
        },
        {
            "location": "/server/",
            "text": "Zend\\XmlRpc\\Server\n\n\nZend\\XmlRpc\\Server\n is a fully-featured XML-RPC server, following\n\nthe specifications outlined at www.xmlrpc.com\n.\nAdditionally, it implements the \nsystem.multicall()\n method, allowing boxcarring\nof requests.\n\n\nBasic Usage\n\n\n$server = new Zend\\XmlRpc\\Server();\n$server-\nsetClass('My\\Service\\Class');\necho $server-\nhandle();\n\n\n\n\nServer Structure\n\n\nZend\\XmlRpc\\Server\n is composed of a variety of components, ranging from the\nserver itself to request, response, and fault objects.\n\n\nTo bootstrap \nZend\\XmlRpc\\Server\n, the developer must attach one or more classes\nor functions to the server, via the \nsetClass()\n and \naddFunction()\n methods.\n\n\nOnce done, you may either pass a \nZend\\XmlRpc\\Request\n object to\n\nZend\\XmlRpc\\Server::handle()\n, or it will instantiate a\n\nZend\\XmlRpc\\Request\\Http\n object if none is provided, thus grabbing the request\nfrom \nphp://input\n.\n\n\nZend\\XmlRpc\\Server::handle()\n then attempts to dispatch to the appropriate\nhandler based on the method requested. It then returns either a\n\nZend\\XmlRpc\\Response\n-based object or a \nZend\\XmlRpc\\Server\\Fault\n object.\nThese objects both have \n__toString()\n methods that create valid XML-RPC XML\nresponses, allowing them to be directly echoed.\n\n\nAnatomy of a webservice\n\n\nGeneral considerations\n\n\nFor maximum performance it is recommended to use a simple bootstrap file for the\nserver component.  Using \nZend\\XmlRpc\\Server\n inside a\n\nZend\\Mvc\\Controller\n is strongly\ndiscouraged to avoid the overhead.\n\n\nServices change over time and while webservices are generally less change\nintense as code-native APIs, it is recommended to version your service. Do so to\nlay grounds to provide compatibility for clients using older versions of your\nservice and manage your service lifecycle including deprecation timeframes. To\ndo so just include a version number into your URI. It is also recommended to\ninclude the remote protocol name in the URI to allow easy integration of\nupcoming remoting technologies. \nhttp://myservice.ws/1.0/XMLRPC/\n.\n\n\nWhat to expose?\n\n\nMost of the time it is not sensible to expose business objects directly.\nBusiness objects are usually small and under heavy change, because change is\ncheap in this layer of your application.  Once deployed and adopted, web\nservices are hard to change. Another concern is I/O and latency: the best\nwebservice calls are those not happening. Therefore service calls need to be\nmore coarse-grained than usual business logic is. Often an additional layer in\nfront of your business objects makes sense. This layer is sometimes referred to\nas \nRemote Facade\n. Such a\nservice layer adds a coarse grained interface on top of your business logic and\ngroups verbose operations into smaller ones.\n\n\nConventions\n\n\nZend\\XmlRpc\\Server\n allows the developer to attach functions and class method\ncalls as dispatchable XML-RPC methods. Via \nZend\\Server\\Reflection\n, it does\nintrospection on all attached methods, using the function and method docblocks\nto determine the method help text and method signatures.\n\n\nXML-RPC types do not necessarily map one-to-one to PHP types. However, the code\nwill do its best to guess the appropriate type based on the values listed in\n\n@param\n and \n@return\n annotations. Some XML-RPC types have no immediate PHP\nequivalent, however, and should be hinted using the XML-RPC type in the PHPDoc.\nThese include:\n\n\n\n\ndateTime.iso8601\n, a string formatted as '\nYYYYMMDDTHH:mm:ss\n'\n\n\nbase64\n, base64 encoded data\n\n\nstruct\n, any associative array\n\n\n\n\nAn example of how to hint follows:\n\n\n/**\n * This is a sample function\n *\n * @param base64 $val1 Base64-encoded data\n * @param dateTime.iso8601 $val2 An ISO date\n * @param struct $val3 An associative array\n * @return struct\n */\nfunction myFunc($val1, $val2, $val3)\n{\n}\n\n\n\n\nPhpDocumentor does not validate types specified for params or return values, so\nthis will have no impact on your API documentation. Providing the hinting is\nnecessary, however, when the server is validating the parameters provided to the\nmethod call.\n\n\nIt is perfectly valid to specify multiple types for both params and return\nvalues; the XML-RPC specification even suggests that \nsystem.methodSignature\n\nshould return an array of all possible method signatures (i.e., all possible\ncombinations of param and return values). You may do so just as you normally\nwould with PhpDocumentor, using the \n|\n operator:\n\n\n/**\n * This is a sample function\n *\n * @param string|base64 $val1 String or base64-encoded data\n * @param string|dateTime.iso8601 $val2 String or an ISO date\n * @param array|struct $val3 Normal indexed array or an associative array\n * @return boolean|struct\n */\nfunction myFunc($val1, $val2, $val3)\n{\n}\n\n\n\n\n\n\nUse multiple values sparingly\n\n\nAllowing multiple signatures can lead to confusion for developers using the\nservices; to keep things simple, a XML-RPC service method should typically\nonly present a single signature.\n\n\n\n\nUtilizing Namespaces\n\n\nXML-RPC allows grouping related methods under dot-delimited \nnamespaces\n. This\nhelps prevent naming collisions between methods served by different classes. As\nan example, the XML-RPC server is expected to server several methods in the\n\nsystem\n namespace:\n\n\n\n\nsystem.listMethods\n\n\nsystem.methodHelp\n\n\nsystem.methodSignature\n\n\n\n\nInternally, these map to the methods of the same name in \nZend\\XmlRpc\\Server\n.\n\n\nIf you want to add namespaces to the methods you serve, simply provide a\nnamespace to the appropriate method when attaching a function or class:\n\n\n// All public methods in My\\Service\\Class will be accessible as\n// myservice.METHODNAME\n$server-\nsetClass('My\\Service\\Class', 'myservice');\n\n// Function 'somefunc' will be accessible as funcs.somefunc\n$server-\naddFunction('somefunc', 'funcs');\n\n\n\n\nCustom Request Objects\n\n\nMost of the time, you'll simply use the default request type included with\n\nZend\\XmlRpc\\Server\n, \nZend\\XmlRpc\\Request\\Http\n. However, there may be times\nwhen you need XML-RPC to be available via the CLI, a GUI, or other environment,\nor want to log incoming requests. To do so, you may create a custom request\nobject that extends \nZend\\XmlRpc\\Request\n. The most important thing to remember\nis to ensure that the \ngetMethod()\n and \ngetParams()\n methods are implemented so\nthat the XML-RPC server can retrieve that information in order to dispatch the\nrequest.\n\n\nCustom Responses\n\n\nSimilar to request objects, \nZend\\XmlRpc\\Server\n can return custom response\nobjects; by default, a \nZend\\XmlRpc\\Response\\Http\n object is returned, which\nsends an appropriate \nContent-Type\n HTTP header for use with XML-RPC. Possible\nuses of a custom object would be to log responses, or to send responses back to\n\nSTDOUT\n.\n\n\nTo use a custom response class, use \nZend\\XmlRpc\\Server::setResponseClass()\n\nprior to calling \nhandle()\n.\n\n\nHandling Exceptions via Faults\n\n\nZend\\XmlRpc\\Server\n catches Exceptions generated by a dispatched method, and\ngenerates an XML-RPC fault response when such an exception is caught. By\ndefault, however, the exception messages and codes are not used in a fault\nresponse. This is an intentional decision to protect your code; many exceptions\nexpose more information about the code or environment than a developer would\nnecessarily intend (a prime example includes database exceptions).\n\n\nException classes can be whitelisted to be used as fault responses, however. To\ndo so, call \nZend\\XmlRpc\\Server\\Fault::attachFaultException()\n and pass an\nexception class to whitelist:\n\n\nZend\\XmlRpc\\Server\\Fault::attachFaultException('My\\Project\\Exception');\n\n\n\n\nIf you utilize an exception class that your other project exceptions inherit,\nyou can then whitelist a whole family of exceptions at a time.\n\nZend\\XmlRpc\\Server\\Exception\ns are always whitelisted, to allow reporting\nspecific internal errors (undefined methods, etc.).\n\n\nAny exception not specifically whitelisted will generate a fault response with a\ncode of '404' and a message of 'Unknown error'.\n\n\nCaching Server Definitions Between Requests\n\n\nAttaching many classes to an XML-RPC server instance can utilize a lot of\nresources; each class must introspect using the Reflection API (via\n\nZend\\Server\\Reflection\n), which in turn generates a list of all possible method\nsignatures to provide to the server class.\n\n\nTo reduce this performance hit somewhat, \nZend\\XmlRpc\\Server\\Cache\n can be used\nto cache the server definition between requests.\n\n\nAn sample usage follows:\n\n\nuse My\\Service as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\n\n$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';\n$server = new XmlRpcServer();\n\nif (! XmlRpcServer\\Cache::get($cacheFile, $server)) {\n\n    $server-\nsetClass(s\\Glue::class, 'glue');   // glue. namespace\n    $server-\nsetClass(s\\Paste::class, 'paste'); // paste. namespace\n    $server-\nsetClass(s\\Tape::class, 'tape');   // tape. namespace\n\n    XmlRpcServer\\Cache::save($cacheFile, $server);\n}\n\necho $server-\nhandle();\n\n\n\n\nThe above example attempts to retrieve a server definition from \nxmlrpc.cache\n\nin the same directory as the script. If unsuccessful, it loads the service\nclasses it needs, attaches them to the server instance, and then attempts to\ncreate a new cache file with the server definition.\n\n\nUsage Examples\n\n\nBelow are several usage examples, showing the full spectrum of options available\nto developers.  Usage examples will each build on the previous example provided.\n\n\nBasic Usage\n\n\nThe example below attaches a function as a dispatchable XML-RPC method and\nhandles incoming calls.\n\n\n/**\n * Return the MD5 sum of a value\n *\n * @param string $value Value to md5sum\n * @return string MD5 sum of value\n */\nfunction md5Value($value)\n{\n    return md5($value);\n}\n\n$server = new Zend\\XmlRpc\\Server();\n$server-\naddFunction('md5Value');\necho $server-\nhandle();\n\n\n\n\nAttaching a class\n\n\nThe example below illustrates attaching a class' public methods as dispatchable\nXML-RPC methods.\n\n\nrequire_once 'Services/Comb.php';\n\n$server = new Zend\\XmlRpc\\Server();\n$server-\nsetClass('Services\\Comb');\necho $server-\nhandle();\n\n\n\n\nAttaching a class with arguments\n\n\nThe following example illustrates how to attach a class' public methods and\npassing arguments to its methods. This can be used to specify certain defaults\nwhen registering service classes.\n\n\nnamespace Services;\n\nclass PricingService\n{\n    /**\n     * Calculate current price of product with $productId\n     *\n     * @param ProductRepository $productRepository\n     * @param PurchaseRepository $purchaseRepository\n     * @param integer $productId\n     */\n    public function calculate(\n        ProductRepository $productRepository,\n        PurchaseRepository $purchaseRepository,\n        $productId\n    ) {\n        /* ... */\n    }\n}\n\n$server = new Zend\\XmlRpc\\Server();\n$server-\nsetClass(\n    'Services\\PricingService',\n    'pricing',\n    new ProductRepository(),\n    new PurchaseRepository()\n);\n\n\n\n\nThe arguments passed to \nsetClass()\n are injected into the method call\n\npricing.calculate()\n on remote invocation. In the example above, only the\nargument \n$productId\n is expected from the client.\n\n\nPassing arguments only to constructor\n\n\nZend\\XmlRpc\\Server\n allows providing constructor arguments when specifying\nclasses, instead of when invoking methods.\n\n\nTo limit injection to constructors, call \nsendArgumentsToAllMethods\n and pass\n\nFALSE\n as an argument. This disables the default behavior of all arguments\nbeing injected into the remote method. In the example below, the instance of\n\nProductRepository\n and \nPurchaseRepository\n is only injected into the\nconstructor of \nServices\\PricingService2\n.\n\n\nclass Services\\PricingService2\n{\n    /**\n     * @param ProductRepository $productRepository\n     * @param PurchaseRepository $purchaseRepository\n     */\n    public function __construct(\n        ProductRepository $productRepository,\n        PurchaseRepository $purchaseRepository\n    ) {\n        /* ... */\n    }\n\n    /**\n     * Calculate current price of product with $productId\n     *\n     * @param integer $productId\n     * @return double\n     */\n    public function calculate($productId)\n    {\n        ...\n    }\n}\n\n$server = new Zend\\XmlRpc\\Server();\n\n// Tell the server to pass arguments to constructors instead of at invocation:\n$server-\nsendArgumentsToAllMethods(false);\n\n// Map the class:\n$server-\nsetClass(\n    'Services\\PricingService2',\n    'pricing',\n    new ProductRepository(),\n    new PurchaseRepository()\n);\n\n\n\n\nAttaching a class instance\n\n\nsetClass()\n allows registering a previously instantiated class with the server,\ninstead of specifying the class name. Obviously, passing arguments to the\nconstructor is not possible with pre-instantiated classes.\n\n\nAttaching several classes using namespaces\n\n\nThe example below illustrates attaching several classes, each with their own\nnamespace.\n\n\nuse Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\n\n$server = new XmlRpcServer();\n$server-\nsetClass(s\\Comb::class, 'comb');   // methods called as comb.*\n$server-\nsetClass(s\\Brush::class, 'brush'); // methods called as brush.*\n$server-\nsetClass(s\\Pick::class, 'pick');   // methods called as pick.*\necho $server-\nhandle();\n\n\n\n\nSpecifying exceptions to use as valid fault responses\n\n\nThe example below allows any \nServices\\Exception\n-derived class to report its\ncode and message in the fault response.\n\n\nuse Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\nuse Zend\\XmlRpc\\Server\\Fault as XmlRpcFault;\n\n// Allow Services_Exceptions to report as fault responses\nXmlRpcFault::attachFaultException(s\\Exception::class);\n\n$server = new XmlRpcServer();\n$server-\nsetClass(s\\Comb::class, 'comb');   // methods called as comb.*\n$server-\nsetClass(s\\Brush::class, 'brush'); // methods called as brush.*\n$server-\nsetClass(s\\Pick::class, 'pick');   // methods called as pick.*\necho $server-\nhandle();\n\n\n\n\nUtilizing custom request and response objects\n\n\nSome use cases require custom request objects; XML-RPC is not bound to HTTP as a\ntransfer protocol. It is possible to use other transfer protocols like SSH or\ntelnet to send the request and response data over the wire. Another use case is\nauthentication and authorization. When a different transfer protocol is\nrequired, you will need to change the implementation to read request data.\n\n\nThe example below instantiates a custom request class and passes it to the\nserver to handle.\n\n\nuse Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\nuse Zend\\XmlRpc\\Server\\Fault as XmlRpcFault;\n\n// Allow Services_Exceptions to report as fault responses\nXmlRpcFault::attachFaultException(s\\Exception::class);\n\n$server = new XmlRpcServer();\n$server-\nsetClass(s\\Comb::class, 'comb');   // methods called as comb.*\n$server-\nsetClass(s\\Brush::class, 'brush'); // methods called as brush.*\n$server-\nsetClass(s\\Pick::class, 'pick');   // methods called as pick.*\n\n// Create a request object\n$request = new s\\Request();\n\necho $server-\nhandle($request);\n\n\n\n\nSpecifying a custom response class\n\n\nThe example below illustrates specifying a custom response class for the returned response.\n\n\nuse Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\nuse Zend\\XmlRpc\\Server\\Fault as XmlRpcFault;\n\n// Allow Services_Exceptions to report as fault responses\nXmlRpcFault::attachFaultException(s\\Exception::class);\n\n$server = new XmlRpcServer();\n$server-\nsetClass(s\\Comb::class, 'comb');   // methods called as comb.*\n$server-\nsetClass(s\\Brush::class, 'brush'); // methods called as brush.*\n$server-\nsetClass(s\\Pick::class, 'pick');   // methods called as pick.*\n\n// Create a request object\n$request = new s\\Request();\n\n// Utilize a custom response\n$server-\nsetResponseClass(s\\Response::class);\n\necho $server-\nhandle($request);\n\n\n\n\nPerformance optimization\n\n\nCache server definitions between requests\n\n\nThe example below illustrates caching server definitions between requests.\n\n\nuse Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\nuse Zend\\XmlRpc\\Server\\Fault as XmlRpcFault;\n\n// Specify a cache file\n$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';\n\n// Allow Services\\Exceptions to report as fault responses\nXmlRpcFault::attachFaultException(s\\Exception::class);\n\n$server = new XmlRpcServer();\n\n// Attempt to retrieve server definition from cache\nif (! XmlRpcServer\\Cache::get($cacheFile, $server)) {\n    $server-\nsetClass(s\\Comb::class, 'comb');   // methods called as comb.*\n    $server-\nsetClass(s\\Brush::class, 'brush'); // methods called as brush.*\n    $server-\nsetClass(s\\Pick::class, 'pick');   // methods called as pick.*\n\n    // Save cache\n    XmlRpcServer\\Cache::save($cacheFile, $server);\n}\n\n// Create a request object\n$request = new s\\Request();\n\n// Utilize a custom response\n$server-\nsetResponseClass(s\\Response::class);\n\necho $server-\nhandle($request);\n\n\n\n\n\n\nCache file location\n\n\nThe server cache file should be located outside the document root.\n\n\n\n\nOptimizing XML generation\n\n\nZend\\XmlRpc\\Server\n uses \nDOMDocument\n to generate it's XML output. While this\nfunctionality is available on most hosts, it's not always the most performant\nsolution; benchmarks have shown that \nXmlWriter\n performs better.\n\n\nIf \next/xmlwriter\n is available on your host, you can select the\n\nXmlWriter\n-based generator to leverage the performance differences.\n\n\nuse Zend\\XmlRpc;\n\nXmlRpc\\AbstractValue::setGenerator(new XmlRpc\\Generator\\XmlWriter());\n\n$server = new XmlRpc\\Server();\n\n\n\n\n\n\nBenchmark your application\n\n\nPerformance is determined by many parameters, and benchmarks only apply for\nthe specific test case. Differences come from PHP version, installed\nextensions, webserver, and operating system just to name a few. Please make\nsure to benchmark your application on your own and decide which generator to\nuse based on \nyour\n numbers.\n\n\nBenchmark your client\n\n\nOptimization makes sense for the client side too. Just select the alternate\nXML generator before doing any work with \nZend\\XmlRpc\\Client\n.",
            "title": "XML-RPC Servers"
        },
        {
            "location": "/server/#zend92xmlrpc92server",
            "text": "Zend\\XmlRpc\\Server  is a fully-featured XML-RPC server, following the specifications outlined at www.xmlrpc.com .\nAdditionally, it implements the  system.multicall()  method, allowing boxcarring\nof requests.",
            "title": "Zend\\XmlRpc\\Server"
        },
        {
            "location": "/server/#basic-usage",
            "text": "$server = new Zend\\XmlRpc\\Server();\n$server- setClass('My\\Service\\Class');\necho $server- handle();",
            "title": "Basic Usage"
        },
        {
            "location": "/server/#server-structure",
            "text": "Zend\\XmlRpc\\Server  is composed of a variety of components, ranging from the\nserver itself to request, response, and fault objects.  To bootstrap  Zend\\XmlRpc\\Server , the developer must attach one or more classes\nor functions to the server, via the  setClass()  and  addFunction()  methods.  Once done, you may either pass a  Zend\\XmlRpc\\Request  object to Zend\\XmlRpc\\Server::handle() , or it will instantiate a Zend\\XmlRpc\\Request\\Http  object if none is provided, thus grabbing the request\nfrom  php://input .  Zend\\XmlRpc\\Server::handle()  then attempts to dispatch to the appropriate\nhandler based on the method requested. It then returns either a Zend\\XmlRpc\\Response -based object or a  Zend\\XmlRpc\\Server\\Fault  object.\nThese objects both have  __toString()  methods that create valid XML-RPC XML\nresponses, allowing them to be directly echoed.",
            "title": "Server Structure"
        },
        {
            "location": "/server/#anatomy-of-a-webservice",
            "text": "",
            "title": "Anatomy of a webservice"
        },
        {
            "location": "/server/#general-considerations",
            "text": "For maximum performance it is recommended to use a simple bootstrap file for the\nserver component.  Using  Zend\\XmlRpc\\Server  inside a Zend\\Mvc\\Controller  is strongly\ndiscouraged to avoid the overhead.  Services change over time and while webservices are generally less change\nintense as code-native APIs, it is recommended to version your service. Do so to\nlay grounds to provide compatibility for clients using older versions of your\nservice and manage your service lifecycle including deprecation timeframes. To\ndo so just include a version number into your URI. It is also recommended to\ninclude the remote protocol name in the URI to allow easy integration of\nupcoming remoting technologies.  http://myservice.ws/1.0/XMLRPC/ .",
            "title": "General considerations"
        },
        {
            "location": "/server/#what-to-expose",
            "text": "Most of the time it is not sensible to expose business objects directly.\nBusiness objects are usually small and under heavy change, because change is\ncheap in this layer of your application.  Once deployed and adopted, web\nservices are hard to change. Another concern is I/O and latency: the best\nwebservice calls are those not happening. Therefore service calls need to be\nmore coarse-grained than usual business logic is. Often an additional layer in\nfront of your business objects makes sense. This layer is sometimes referred to\nas  Remote Facade . Such a\nservice layer adds a coarse grained interface on top of your business logic and\ngroups verbose operations into smaller ones.",
            "title": "What to expose?"
        },
        {
            "location": "/server/#conventions",
            "text": "Zend\\XmlRpc\\Server  allows the developer to attach functions and class method\ncalls as dispatchable XML-RPC methods. Via  Zend\\Server\\Reflection , it does\nintrospection on all attached methods, using the function and method docblocks\nto determine the method help text and method signatures.  XML-RPC types do not necessarily map one-to-one to PHP types. However, the code\nwill do its best to guess the appropriate type based on the values listed in @param  and  @return  annotations. Some XML-RPC types have no immediate PHP\nequivalent, however, and should be hinted using the XML-RPC type in the PHPDoc.\nThese include:   dateTime.iso8601 , a string formatted as ' YYYYMMDDTHH:mm:ss '  base64 , base64 encoded data  struct , any associative array   An example of how to hint follows:  /**\n * This is a sample function\n *\n * @param base64 $val1 Base64-encoded data\n * @param dateTime.iso8601 $val2 An ISO date\n * @param struct $val3 An associative array\n * @return struct\n */\nfunction myFunc($val1, $val2, $val3)\n{\n}  PhpDocumentor does not validate types specified for params or return values, so\nthis will have no impact on your API documentation. Providing the hinting is\nnecessary, however, when the server is validating the parameters provided to the\nmethod call.  It is perfectly valid to specify multiple types for both params and return\nvalues; the XML-RPC specification even suggests that  system.methodSignature \nshould return an array of all possible method signatures (i.e., all possible\ncombinations of param and return values). You may do so just as you normally\nwould with PhpDocumentor, using the  |  operator:  /**\n * This is a sample function\n *\n * @param string|base64 $val1 String or base64-encoded data\n * @param string|dateTime.iso8601 $val2 String or an ISO date\n * @param array|struct $val3 Normal indexed array or an associative array\n * @return boolean|struct\n */\nfunction myFunc($val1, $val2, $val3)\n{\n}",
            "title": "Conventions"
        },
        {
            "location": "/server/#use-multiple-values-sparingly",
            "text": "Allowing multiple signatures can lead to confusion for developers using the\nservices; to keep things simple, a XML-RPC service method should typically\nonly present a single signature.",
            "title": "Use multiple values sparingly"
        },
        {
            "location": "/server/#utilizing-namespaces",
            "text": "XML-RPC allows grouping related methods under dot-delimited  namespaces . This\nhelps prevent naming collisions between methods served by different classes. As\nan example, the XML-RPC server is expected to server several methods in the system  namespace:   system.listMethods  system.methodHelp  system.methodSignature   Internally, these map to the methods of the same name in  Zend\\XmlRpc\\Server .  If you want to add namespaces to the methods you serve, simply provide a\nnamespace to the appropriate method when attaching a function or class:  // All public methods in My\\Service\\Class will be accessible as\n// myservice.METHODNAME\n$server- setClass('My\\Service\\Class', 'myservice');\n\n// Function 'somefunc' will be accessible as funcs.somefunc\n$server- addFunction('somefunc', 'funcs');",
            "title": "Utilizing Namespaces"
        },
        {
            "location": "/server/#custom-request-objects",
            "text": "Most of the time, you'll simply use the default request type included with Zend\\XmlRpc\\Server ,  Zend\\XmlRpc\\Request\\Http . However, there may be times\nwhen you need XML-RPC to be available via the CLI, a GUI, or other environment,\nor want to log incoming requests. To do so, you may create a custom request\nobject that extends  Zend\\XmlRpc\\Request . The most important thing to remember\nis to ensure that the  getMethod()  and  getParams()  methods are implemented so\nthat the XML-RPC server can retrieve that information in order to dispatch the\nrequest.",
            "title": "Custom Request Objects"
        },
        {
            "location": "/server/#custom-responses",
            "text": "Similar to request objects,  Zend\\XmlRpc\\Server  can return custom response\nobjects; by default, a  Zend\\XmlRpc\\Response\\Http  object is returned, which\nsends an appropriate  Content-Type  HTTP header for use with XML-RPC. Possible\nuses of a custom object would be to log responses, or to send responses back to STDOUT .  To use a custom response class, use  Zend\\XmlRpc\\Server::setResponseClass() \nprior to calling  handle() .",
            "title": "Custom Responses"
        },
        {
            "location": "/server/#handling-exceptions-via-faults",
            "text": "Zend\\XmlRpc\\Server  catches Exceptions generated by a dispatched method, and\ngenerates an XML-RPC fault response when such an exception is caught. By\ndefault, however, the exception messages and codes are not used in a fault\nresponse. This is an intentional decision to protect your code; many exceptions\nexpose more information about the code or environment than a developer would\nnecessarily intend (a prime example includes database exceptions).  Exception classes can be whitelisted to be used as fault responses, however. To\ndo so, call  Zend\\XmlRpc\\Server\\Fault::attachFaultException()  and pass an\nexception class to whitelist:  Zend\\XmlRpc\\Server\\Fault::attachFaultException('My\\Project\\Exception');  If you utilize an exception class that your other project exceptions inherit,\nyou can then whitelist a whole family of exceptions at a time. Zend\\XmlRpc\\Server\\Exception s are always whitelisted, to allow reporting\nspecific internal errors (undefined methods, etc.).  Any exception not specifically whitelisted will generate a fault response with a\ncode of '404' and a message of 'Unknown error'.",
            "title": "Handling Exceptions via Faults"
        },
        {
            "location": "/server/#caching-server-definitions-between-requests",
            "text": "Attaching many classes to an XML-RPC server instance can utilize a lot of\nresources; each class must introspect using the Reflection API (via Zend\\Server\\Reflection ), which in turn generates a list of all possible method\nsignatures to provide to the server class.  To reduce this performance hit somewhat,  Zend\\XmlRpc\\Server\\Cache  can be used\nto cache the server definition between requests.  An sample usage follows:  use My\\Service as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\n\n$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';\n$server = new XmlRpcServer();\n\nif (! XmlRpcServer\\Cache::get($cacheFile, $server)) {\n\n    $server- setClass(s\\Glue::class, 'glue');   // glue. namespace\n    $server- setClass(s\\Paste::class, 'paste'); // paste. namespace\n    $server- setClass(s\\Tape::class, 'tape');   // tape. namespace\n\n    XmlRpcServer\\Cache::save($cacheFile, $server);\n}\n\necho $server- handle();  The above example attempts to retrieve a server definition from  xmlrpc.cache \nin the same directory as the script. If unsuccessful, it loads the service\nclasses it needs, attaches them to the server instance, and then attempts to\ncreate a new cache file with the server definition.",
            "title": "Caching Server Definitions Between Requests"
        },
        {
            "location": "/server/#usage-examples",
            "text": "Below are several usage examples, showing the full spectrum of options available\nto developers.  Usage examples will each build on the previous example provided.",
            "title": "Usage Examples"
        },
        {
            "location": "/server/#basic-usage_1",
            "text": "The example below attaches a function as a dispatchable XML-RPC method and\nhandles incoming calls.  /**\n * Return the MD5 sum of a value\n *\n * @param string $value Value to md5sum\n * @return string MD5 sum of value\n */\nfunction md5Value($value)\n{\n    return md5($value);\n}\n\n$server = new Zend\\XmlRpc\\Server();\n$server- addFunction('md5Value');\necho $server- handle();",
            "title": "Basic Usage"
        },
        {
            "location": "/server/#attaching-a-class",
            "text": "The example below illustrates attaching a class' public methods as dispatchable\nXML-RPC methods.  require_once 'Services/Comb.php';\n\n$server = new Zend\\XmlRpc\\Server();\n$server- setClass('Services\\Comb');\necho $server- handle();",
            "title": "Attaching a class"
        },
        {
            "location": "/server/#attaching-a-class-with-arguments",
            "text": "The following example illustrates how to attach a class' public methods and\npassing arguments to its methods. This can be used to specify certain defaults\nwhen registering service classes.  namespace Services;\n\nclass PricingService\n{\n    /**\n     * Calculate current price of product with $productId\n     *\n     * @param ProductRepository $productRepository\n     * @param PurchaseRepository $purchaseRepository\n     * @param integer $productId\n     */\n    public function calculate(\n        ProductRepository $productRepository,\n        PurchaseRepository $purchaseRepository,\n        $productId\n    ) {\n        /* ... */\n    }\n}\n\n$server = new Zend\\XmlRpc\\Server();\n$server- setClass(\n    'Services\\PricingService',\n    'pricing',\n    new ProductRepository(),\n    new PurchaseRepository()\n);  The arguments passed to  setClass()  are injected into the method call pricing.calculate()  on remote invocation. In the example above, only the\nargument  $productId  is expected from the client.",
            "title": "Attaching a class with arguments"
        },
        {
            "location": "/server/#passing-arguments-only-to-constructor",
            "text": "Zend\\XmlRpc\\Server  allows providing constructor arguments when specifying\nclasses, instead of when invoking methods.  To limit injection to constructors, call  sendArgumentsToAllMethods  and pass FALSE  as an argument. This disables the default behavior of all arguments\nbeing injected into the remote method. In the example below, the instance of ProductRepository  and  PurchaseRepository  is only injected into the\nconstructor of  Services\\PricingService2 .  class Services\\PricingService2\n{\n    /**\n     * @param ProductRepository $productRepository\n     * @param PurchaseRepository $purchaseRepository\n     */\n    public function __construct(\n        ProductRepository $productRepository,\n        PurchaseRepository $purchaseRepository\n    ) {\n        /* ... */\n    }\n\n    /**\n     * Calculate current price of product with $productId\n     *\n     * @param integer $productId\n     * @return double\n     */\n    public function calculate($productId)\n    {\n        ...\n    }\n}\n\n$server = new Zend\\XmlRpc\\Server();\n\n// Tell the server to pass arguments to constructors instead of at invocation:\n$server- sendArgumentsToAllMethods(false);\n\n// Map the class:\n$server- setClass(\n    'Services\\PricingService2',\n    'pricing',\n    new ProductRepository(),\n    new PurchaseRepository()\n);",
            "title": "Passing arguments only to constructor"
        },
        {
            "location": "/server/#attaching-a-class-instance",
            "text": "setClass()  allows registering a previously instantiated class with the server,\ninstead of specifying the class name. Obviously, passing arguments to the\nconstructor is not possible with pre-instantiated classes.",
            "title": "Attaching a class instance"
        },
        {
            "location": "/server/#attaching-several-classes-using-namespaces",
            "text": "The example below illustrates attaching several classes, each with their own\nnamespace.  use Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\n\n$server = new XmlRpcServer();\n$server- setClass(s\\Comb::class, 'comb');   // methods called as comb.*\n$server- setClass(s\\Brush::class, 'brush'); // methods called as brush.*\n$server- setClass(s\\Pick::class, 'pick');   // methods called as pick.*\necho $server- handle();",
            "title": "Attaching several classes using namespaces"
        },
        {
            "location": "/server/#specifying-exceptions-to-use-as-valid-fault-responses",
            "text": "The example below allows any  Services\\Exception -derived class to report its\ncode and message in the fault response.  use Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\nuse Zend\\XmlRpc\\Server\\Fault as XmlRpcFault;\n\n// Allow Services_Exceptions to report as fault responses\nXmlRpcFault::attachFaultException(s\\Exception::class);\n\n$server = new XmlRpcServer();\n$server- setClass(s\\Comb::class, 'comb');   // methods called as comb.*\n$server- setClass(s\\Brush::class, 'brush'); // methods called as brush.*\n$server- setClass(s\\Pick::class, 'pick');   // methods called as pick.*\necho $server- handle();",
            "title": "Specifying exceptions to use as valid fault responses"
        },
        {
            "location": "/server/#utilizing-custom-request-and-response-objects",
            "text": "Some use cases require custom request objects; XML-RPC is not bound to HTTP as a\ntransfer protocol. It is possible to use other transfer protocols like SSH or\ntelnet to send the request and response data over the wire. Another use case is\nauthentication and authorization. When a different transfer protocol is\nrequired, you will need to change the implementation to read request data.  The example below instantiates a custom request class and passes it to the\nserver to handle.  use Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\nuse Zend\\XmlRpc\\Server\\Fault as XmlRpcFault;\n\n// Allow Services_Exceptions to report as fault responses\nXmlRpcFault::attachFaultException(s\\Exception::class);\n\n$server = new XmlRpcServer();\n$server- setClass(s\\Comb::class, 'comb');   // methods called as comb.*\n$server- setClass(s\\Brush::class, 'brush'); // methods called as brush.*\n$server- setClass(s\\Pick::class, 'pick');   // methods called as pick.*\n\n// Create a request object\n$request = new s\\Request();\n\necho $server- handle($request);",
            "title": "Utilizing custom request and response objects"
        },
        {
            "location": "/server/#specifying-a-custom-response-class",
            "text": "The example below illustrates specifying a custom response class for the returned response.  use Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\nuse Zend\\XmlRpc\\Server\\Fault as XmlRpcFault;\n\n// Allow Services_Exceptions to report as fault responses\nXmlRpcFault::attachFaultException(s\\Exception::class);\n\n$server = new XmlRpcServer();\n$server- setClass(s\\Comb::class, 'comb');   // methods called as comb.*\n$server- setClass(s\\Brush::class, 'brush'); // methods called as brush.*\n$server- setClass(s\\Pick::class, 'pick');   // methods called as pick.*\n\n// Create a request object\n$request = new s\\Request();\n\n// Utilize a custom response\n$server- setResponseClass(s\\Response::class);\n\necho $server- handle($request);",
            "title": "Specifying a custom response class"
        },
        {
            "location": "/server/#performance-optimization",
            "text": "",
            "title": "Performance optimization"
        },
        {
            "location": "/server/#cache-server-definitions-between-requests",
            "text": "The example below illustrates caching server definitions between requests.  use Services as s;\nuse Zend\\XmlRpc\\Server as XmlRpcServer;\nuse Zend\\XmlRpc\\Server\\Fault as XmlRpcFault;\n\n// Specify a cache file\n$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';\n\n// Allow Services\\Exceptions to report as fault responses\nXmlRpcFault::attachFaultException(s\\Exception::class);\n\n$server = new XmlRpcServer();\n\n// Attempt to retrieve server definition from cache\nif (! XmlRpcServer\\Cache::get($cacheFile, $server)) {\n    $server- setClass(s\\Comb::class, 'comb');   // methods called as comb.*\n    $server- setClass(s\\Brush::class, 'brush'); // methods called as brush.*\n    $server- setClass(s\\Pick::class, 'pick');   // methods called as pick.*\n\n    // Save cache\n    XmlRpcServer\\Cache::save($cacheFile, $server);\n}\n\n// Create a request object\n$request = new s\\Request();\n\n// Utilize a custom response\n$server- setResponseClass(s\\Response::class);\n\necho $server- handle($request);",
            "title": "Cache server definitions between requests"
        },
        {
            "location": "/server/#cache-file-location",
            "text": "The server cache file should be located outside the document root.",
            "title": "Cache file location"
        },
        {
            "location": "/server/#optimizing-xml-generation",
            "text": "Zend\\XmlRpc\\Server  uses  DOMDocument  to generate it's XML output. While this\nfunctionality is available on most hosts, it's not always the most performant\nsolution; benchmarks have shown that  XmlWriter  performs better.  If  ext/xmlwriter  is available on your host, you can select the XmlWriter -based generator to leverage the performance differences.  use Zend\\XmlRpc;\n\nXmlRpc\\AbstractValue::setGenerator(new XmlRpc\\Generator\\XmlWriter());\n\n$server = new XmlRpc\\Server();",
            "title": "Optimizing XML generation"
        },
        {
            "location": "/server/#benchmark-your-application",
            "text": "Performance is determined by many parameters, and benchmarks only apply for\nthe specific test case. Differences come from PHP version, installed\nextensions, webserver, and operating system just to name a few. Please make\nsure to benchmark your application on your own and decide which generator to\nuse based on  your  numbers.",
            "title": "Benchmark your application"
        },
        {
            "location": "/server/#benchmark-your-client",
            "text": "Optimization makes sense for the client side too. Just select the alternate\nXML generator before doing any work with  Zend\\XmlRpc\\Client .",
            "title": "Benchmark your client"
        }
    ]
}